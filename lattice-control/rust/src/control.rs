// This file is @generated by wasmcloud/weld-codegen 0.4.6.
// It is not intended for manual editing.
// namespace: org.wasmcloud.lattice.control

#[allow(unused_imports)]
use async_trait::async_trait;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use std::{borrow::Borrow, borrow::Cow, io::Write, string::ToString};
#[allow(unused_imports)]
use wasmbus_rpc::{
    cbor::*,
    common::{
        deserialize, message_format, serialize, Context, Message, MessageDispatch, MessageFormat,
        SendOpts, Transport,
    },
    error::{RpcError, RpcResult},
    Timestamp,
};

#[allow(dead_code)]
pub const SMITHY_VERSION: &str = "1.0";

/// One of a potential list of responses to an actor auction
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ActorAuctionAck {
    /// The original actor reference used for the auction
    #[serde(default)]
    pub actor_ref: String,
    /// The host ID of the "bidder" for this auction.
    #[serde(default)]
    pub host_id: String,
}

// Encode ActorAuctionAck as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_actor_auction_ack<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ActorAuctionAck,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("actorRef")?;
    e.str(&val.actor_ref)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    Ok(())
}

// Decode ActorAuctionAck from cbor input stream
#[doc(hidden)]
pub fn decode_actor_auction_ack(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ActorAuctionAck, RpcError> {
    let __result = {
        let mut actor_ref: Option<String> = None;
        let mut host_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ActorAuctionAck, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => actor_ref = Some(d.str()?.to_string()),
                    1 => host_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actorRef" => actor_ref = Some(d.str()?.to_string()),
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        ActorAuctionAck {
            actor_ref: if let Some(__x) = actor_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorAuctionAck.actor_ref (#0)".to_string(),
                ));
            },

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorAuctionAck.host_id (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type ActorAuctionAcks = Vec<ActorAuctionAck>;

// Encode ActorAuctionAcks as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_actor_auction_acks<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ActorAuctionAcks,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_actor_auction_ack(e, item)?;
    }
    Ok(())
}

// Decode ActorAuctionAcks from cbor input stream
#[doc(hidden)]
pub fn decode_actor_auction_acks(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ActorAuctionAcks, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<ActorAuctionAck> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_actor_auction_ack(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.lattice.control#ActorAuctionAck': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<ActorAuctionAck> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_actor_auction_ack(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.lattice.control#ActorAuctionAck': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// A request to locate suitable hosts for a given actor
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ActorAuctionRequest {
    /// The reference for this actor. Can be any one of the acceptable forms
    /// of uniquely identifying an actor.
    #[serde(default)]
    pub actor_ref: String,
    /// The set of constraints to which any candidate host must conform
    pub constraints: ConstraintMap,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
}

// Encode ActorAuctionRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_actor_auction_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ActorAuctionRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("actorRef")?;
    e.str(&val.actor_ref)?;
    e.str("constraints")?;
    encode_constraint_map(e, &val.constraints)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    Ok(())
}

// Decode ActorAuctionRequest from cbor input stream
#[doc(hidden)]
pub fn decode_actor_auction_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ActorAuctionRequest, RpcError> {
    let __result = {
        let mut actor_ref: Option<String> = None;
        let mut constraints: Option<ConstraintMap> = None;
        let mut lattice_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ActorAuctionRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => actor_ref = Some(d.str()?.to_string()),
                    1 => {
                        constraints = Some(decode_constraint_map(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ConstraintMap': {}",
                                e
                            )
                        })?)
                    }
                    2 => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actorRef" => actor_ref = Some(d.str()?.to_string()),
                    "constraints" => {
                        constraints = Some(decode_constraint_map(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ConstraintMap': {}",
                                e
                            )
                        })?)
                    }
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        ActorAuctionRequest {
            actor_ref: if let Some(__x) = actor_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorAuctionRequest.actor_ref (#0)".to_string(),
                ));
            },

            constraints: if let Some(__x) = constraints {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorAuctionRequest.constraints (#1)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorAuctionRequest.lattice_id (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A summary description of an actor within a host inventory
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ActorDescription {
    /// Actor's 56-character unique ID
    #[serde(default)]
    pub id: String,
    /// Image reference for this actor, if applicable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_ref: Option<String>,
    /// The individual instances of this actor that are running
    pub instances: ActorInstances,
    /// Name of this actor, if one exists
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

// Encode ActorDescription as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_actor_description<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ActorDescription,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(4)?;
    e.str("id")?;
    e.str(&val.id)?;
    if let Some(val) = val.image_ref.as_ref() {
        e.str("imageRef")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("instances")?;
    encode_actor_instances(e, &val.instances)?;
    if let Some(val) = val.name.as_ref() {
        e.str("name")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode ActorDescription from cbor input stream
#[doc(hidden)]
pub fn decode_actor_description(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ActorDescription, RpcError> {
    let __result = {
        let mut id: Option<String> = None;
        let mut image_ref: Option<Option<String>> = Some(None);
        let mut instances: Option<ActorInstances> = None;
        let mut name: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ActorDescription, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => id = Some(d.str()?.to_string()),
                    1 => {
                        image_ref = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        instances = Some(decode_actor_instances(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ActorInstances': {}",
                                e
                            )
                        })?)
                    }
                    3 => {
                        name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "id" => id = Some(d.str()?.to_string()),
                    "imageRef" => {
                        image_ref = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "instances" => {
                        instances = Some(decode_actor_instances(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ActorInstances': {}",
                                e
                            )
                        })?)
                    }
                    "name" => {
                        name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        ActorDescription {
            id: if let Some(__x) = id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorDescription.id (#0)".to_string(),
                ));
            },
            image_ref: image_ref.unwrap(),

            instances: if let Some(__x) = instances {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorDescription.instances (#2)".to_string(),
                ));
            },
            name: name.unwrap(),
        }
    };
    Ok(__result)
}
pub type ActorDescriptions = Vec<ActorDescription>;

// Encode ActorDescriptions as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_actor_descriptions<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ActorDescriptions,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_actor_description(e, item)?;
    }
    Ok(())
}

// Decode ActorDescriptions from cbor input stream
#[doc(hidden)]
pub fn decode_actor_descriptions(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ActorDescriptions, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<ActorDescription> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_actor_description(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.lattice.control#ActorDescription': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<ActorDescription> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_actor_description(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.lattice.control#ActorDescription': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ActorInstance {
    /// The annotations that were used in the start request that produced
    /// this actor instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<AnnotationMap>,
    /// This instance's unique ID (guid)
    #[serde(default)]
    pub instance_id: String,
    /// The revision number for this actor instance
    #[serde(default)]
    pub revision: i32,
}

// Encode ActorInstance as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_actor_instance<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ActorInstance,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    if let Some(val) = val.annotations.as_ref() {
        e.str("annotations")?;
        encode_annotation_map(e, val)?;
    } else {
        e.null()?;
    }
    e.str("instanceId")?;
    e.str(&val.instance_id)?;
    e.str("revision")?;
    e.i32(val.revision)?;
    Ok(())
}

// Decode ActorInstance from cbor input stream
#[doc(hidden)]
pub fn decode_actor_instance(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ActorInstance, RpcError> {
    let __result = {
        let mut annotations: Option<Option<AnnotationMap>> = Some(None);
        let mut instance_id: Option<String> = None;
        let mut revision: Option<i32> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ActorInstance, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    1 => instance_id = Some(d.str()?.to_string()),
                    2 => revision = Some(d.i32()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "annotations" => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "instanceId" => instance_id = Some(d.str()?.to_string()),
                    "revision" => revision = Some(d.i32()?),
                    _ => d.skip()?,
                }
            }
        }
        ActorInstance {
            annotations: annotations.unwrap(),

            instance_id: if let Some(__x) = instance_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorInstance.instance_id (#1)".to_string(),
                ));
            },

            revision: if let Some(__x) = revision {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ActorInstance.revision (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type ActorInstances = Vec<ActorInstance>;

// Encode ActorInstances as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_actor_instances<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ActorInstances,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_actor_instance(e, item)?;
    }
    Ok(())
}

// Decode ActorInstances from cbor input stream
#[doc(hidden)]
pub fn decode_actor_instances(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ActorInstances, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<ActorInstance> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_actor_instance(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.lattice.control#ActorInstance': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<ActorInstance> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_actor_instance(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.lattice.control#ActorInstance': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct AdvertiseLinkRequest {
    /// The ID of the lattice for this request
    #[serde(default)]
    pub lattice_id: String,
    pub link: wasmbus_rpc::core::LinkDefinition,
}

// Encode AdvertiseLinkRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_advertise_link_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &AdvertiseLinkRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    e.str("link")?;
    wasmbus_rpc::core::encode_link_definition(e, &val.link)?;
    Ok(())
}

// Decode AdvertiseLinkRequest from cbor input stream
#[doc(hidden)]
pub fn decode_advertise_link_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<AdvertiseLinkRequest, RpcError> {
    let __result = {
        let mut lattice_id: Option<String> = None;
        let mut link: Option<wasmbus_rpc::core::LinkDefinition> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct AdvertiseLinkRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => lattice_id = Some(d.str()?.to_string()),
                    1 => {
                        link = Some(wasmbus_rpc::core::decode_link_definition(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.core#LinkDefinition': {}", e)
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "link" => {
                        link = Some(wasmbus_rpc::core::decode_link_definition(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.core#LinkDefinition': {}", e)
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        }
        AdvertiseLinkRequest {
            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field AdvertiseLinkRequest.lattice_id (#0)".to_string(),
                ));
            },

            link: if let Some(__x) = link {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field AdvertiseLinkRequest.link (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type AnnotationMap = std::collections::HashMap<String, String>;

// Encode AnnotationMap as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_annotation_map<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &AnnotationMap,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(val.len() as u64)?;
    for (k, v) in val {
        e.str(k)?;
        e.str(v)?;
    }
    Ok(())
}

// Decode AnnotationMap from cbor input stream
#[doc(hidden)]
pub fn decode_annotation_map(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<AnnotationMap, RpcError> {
    let __result = {
        {
            let map_len = d.fixed_map()? as usize;
            let mut m: std::collections::HashMap<String, String> =
                std::collections::HashMap::with_capacity(map_len);
            for _ in 0..map_len {
                let k = d.str()?.to_string();
                let v = d.str()?.to_string();
                m.insert(k, v);
            }
            m
        }
    };
    Ok(__result)
}
pub type ConfigurationString = String;

// Encode ConfigurationString as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_configuration_string<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ConfigurationString,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.str(val)?;
    Ok(())
}

// Decode ConfigurationString from cbor input stream
#[doc(hidden)]
pub fn decode_configuration_string(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ConfigurationString, RpcError> {
    let __result = { d.str()?.to_string() };
    Ok(__result)
}
pub type ConstraintMap = std::collections::HashMap<String, String>;

// Encode ConstraintMap as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_constraint_map<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ConstraintMap,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(val.len() as u64)?;
    for (k, v) in val {
        e.str(k)?;
        e.str(v)?;
    }
    Ok(())
}

// Decode ConstraintMap from cbor input stream
#[doc(hidden)]
pub fn decode_constraint_map(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ConstraintMap, RpcError> {
    let __result = {
        {
            let map_len = d.fixed_map()? as usize;
            let mut m: std::collections::HashMap<String, String> =
                std::collections::HashMap::with_capacity(map_len);
            for _ in 0..map_len {
                let k = d.str()?.to_string();
                let v = d.str()?.to_string();
                m.insert(k, v);
            }
            m
        }
    };
    Ok(__result)
}
pub type CtlKVList = Vec<KeyValueMap>;

// Encode CtlKVList as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_ctl_kv_list<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &CtlKVList,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_key_value_map(e, item)?;
    }
    Ok(())
}

// Decode CtlKVList from cbor input stream
#[doc(hidden)]
pub fn decode_ctl_kv_list(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<CtlKVList, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<KeyValueMap> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_key_value_map(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.lattice.control#KeyValueMap': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<KeyValueMap> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_key_value_map(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.lattice.control#KeyValueMap': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// Standard response for control interface operations
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct CtlOperationAck {
    #[serde(default)]
    pub accepted: bool,
    #[serde(default)]
    pub error: String,
}

// Encode CtlOperationAck as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_ctl_operation_ack<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &CtlOperationAck,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("accepted")?;
    e.bool(val.accepted)?;
    e.str("error")?;
    e.str(&val.error)?;
    Ok(())
}

// Decode CtlOperationAck from cbor input stream
#[doc(hidden)]
pub fn decode_ctl_operation_ack(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<CtlOperationAck, RpcError> {
    let __result = {
        let mut accepted: Option<bool> = None;
        let mut error: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct CtlOperationAck, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => accepted = Some(d.bool()?),
                    1 => error = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "accepted" => accepted = Some(d.bool()?),
                    "error" => error = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        CtlOperationAck {
            accepted: if let Some(__x) = accepted {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field CtlOperationAck.accepted (#0)".to_string(),
                ));
            },

            error: if let Some(__x) = error {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field CtlOperationAck.error (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct GetClaimsRequest {
    /// The ID of the lattice for this request
    #[serde(default)]
    pub lattice_id: String,
}

// Encode GetClaimsRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_get_claims_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &GetClaimsRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(1)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    Ok(())
}

// Decode GetClaimsRequest from cbor input stream
#[doc(hidden)]
pub fn decode_get_claims_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<GetClaimsRequest, RpcError> {
    let __result = {
        let mut lattice_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct GetClaimsRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        GetClaimsRequest {
            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field GetClaimsRequest.lattice_id (#0)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A response containing the full list of known claims within the lattice
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct GetClaimsResponse {
    pub claims: CtlKVList,
}

// Encode GetClaimsResponse as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_get_claims_response<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &GetClaimsResponse,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(1)?;
    e.str("claims")?;
    encode_ctl_kv_list(e, &val.claims)?;
    Ok(())
}

// Decode GetClaimsResponse from cbor input stream
#[doc(hidden)]
pub fn decode_get_claims_response(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<GetClaimsResponse, RpcError> {
    let __result = {
        let mut claims: Option<CtlKVList> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct GetClaimsResponse, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        claims = Some(decode_ctl_kv_list(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.lattice.control#CtlKVList': {}", e)
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "claims" => {
                        claims = Some(decode_ctl_kv_list(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.lattice.control#CtlKVList': {}", e)
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        }
        GetClaimsResponse {
            claims: if let Some(__x) = claims {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field GetClaimsResponse.claims (#0)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct GetHostInventoryRequest {
    /// The public key of the host being targeted for this request
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice for this request
    #[serde(default)]
    pub lattice_id: String,
}

// Encode GetHostInventoryRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_get_host_inventory_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &GetHostInventoryRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    Ok(())
}

// Decode GetHostInventoryRequest from cbor input stream
#[doc(hidden)]
pub fn decode_get_host_inventory_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<GetHostInventoryRequest, RpcError> {
    let __result = {
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct GetHostInventoryRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => host_id = Some(d.str()?.to_string()),
                    1 => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        GetHostInventoryRequest {
            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field GetHostInventoryRequest.host_id (#0)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field GetHostInventoryRequest.lattice_id (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct GetHostsRequest {
    /// The ID of the lattice for which these credentials will be used
    #[serde(default)]
    pub lattice_id: String,
}

// Encode GetHostsRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_get_hosts_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &GetHostsRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(1)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    Ok(())
}

// Decode GetHostsRequest from cbor input stream
#[doc(hidden)]
pub fn decode_get_hosts_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<GetHostsRequest, RpcError> {
    let __result = {
        let mut lattice_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct GetHostsRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        GetHostsRequest {
            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field GetHostsRequest.lattice_id (#0)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A summary representation of a host
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Host {
    /// Comma-delimited list of valid cluster issuer public keys as known
    /// to this host
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster_issuers: Option<String>,
    /// NATS server host used for the control interface
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ctl_host: Option<String>,
    #[serde(default)]
    pub id: String,
    /// JetStream domain (if applicable) in use by this host
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub js_domain: Option<String>,
    /// Hash map of label-value pairs for this host
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<KeyValueMap>,
    /// Lattice prefix/ID used by the host
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lattice_prefix: Option<String>,
    /// NATS server host used for provider RPC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prov_rpc_host: Option<String>,
    /// NATS server host used for regular RPC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rpc_host: Option<String>,
    /// Human-friendly uptime description
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uptime_human: Option<String>,
    /// uptime in seconds
    #[serde(default)]
    pub uptime_seconds: u64,
    /// Current wasmCloud Host software version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

// Encode Host as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_host<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Host,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(11)?;
    if let Some(val) = val.cluster_issuers.as_ref() {
        e.str("clusterIssuers")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.ctl_host.as_ref() {
        e.str("ctlHost")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("id")?;
    e.str(&val.id)?;
    if let Some(val) = val.js_domain.as_ref() {
        e.str("jsDomain")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.labels.as_ref() {
        e.str("labels")?;
        encode_key_value_map(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.lattice_prefix.as_ref() {
        e.str("latticePrefix")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.prov_rpc_host.as_ref() {
        e.str("provRpcHost")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.rpc_host.as_ref() {
        e.str("rpcHost")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.uptime_human.as_ref() {
        e.str("uptimeHuman")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("uptimeSeconds")?;
    e.u64(val.uptime_seconds)?;
    if let Some(val) = val.version.as_ref() {
        e.str("version")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode Host from cbor input stream
#[doc(hidden)]
pub fn decode_host(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Host, RpcError> {
    let __result = {
        let mut cluster_issuers: Option<Option<String>> = Some(None);
        let mut ctl_host: Option<Option<String>> = Some(None);
        let mut id: Option<String> = None;
        let mut js_domain: Option<Option<String>> = Some(None);
        let mut labels: Option<Option<KeyValueMap>> = Some(None);
        let mut lattice_prefix: Option<Option<String>> = Some(None);
        let mut prov_rpc_host: Option<Option<String>> = Some(None);
        let mut rpc_host: Option<Option<String>> = Some(None);
        let mut uptime_human: Option<Option<String>> = Some(None);
        let mut uptime_seconds: Option<u64> = None;
        let mut version: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Host, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        cluster_issuers = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => {
                        ctl_host = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => id = Some(d.str()?.to_string()),
                    3 => {
                        js_domain = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        labels = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_key_value_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#KeyValueMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    5 => {
                        lattice_prefix = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    6 => {
                        prov_rpc_host = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    7 => {
                        rpc_host = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    8 => {
                        uptime_human = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    9 => uptime_seconds = Some(d.u64()?),
                    10 => {
                        version = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "clusterIssuers" => {
                        cluster_issuers = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "ctlHost" => {
                        ctl_host = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "id" => id = Some(d.str()?.to_string()),
                    "jsDomain" => {
                        js_domain = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "labels" => {
                        labels = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_key_value_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#KeyValueMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "latticePrefix" => {
                        lattice_prefix = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "provRpcHost" => {
                        prov_rpc_host = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "rpcHost" => {
                        rpc_host = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "uptimeHuman" => {
                        uptime_human = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "uptimeSeconds" => uptime_seconds = Some(d.u64()?),
                    "version" => {
                        version = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        Host {
            cluster_issuers: cluster_issuers.unwrap(),
            ctl_host: ctl_host.unwrap(),

            id: if let Some(__x) = id {
                __x
            } else {
                return Err(RpcError::Deser("missing field Host.id (#2)".to_string()));
            },
            js_domain: js_domain.unwrap(),
            labels: labels.unwrap(),
            lattice_prefix: lattice_prefix.unwrap(),
            prov_rpc_host: prov_rpc_host.unwrap(),
            rpc_host: rpc_host.unwrap(),
            uptime_human: uptime_human.unwrap(),

            uptime_seconds: if let Some(__x) = uptime_seconds {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Host.uptime_seconds (#9)".to_string(),
                ));
            },
            version: version.unwrap(),
        }
    };
    Ok(__result)
}
/// Describes the known contents of a given host at the time of
/// a query
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct HostInventory {
    /// Actors running on this host.
    pub actors: ActorDescriptions,
    /// The host's unique ID
    #[serde(default)]
    pub host_id: String,
    /// The host's labels
    pub labels: LabelsMap,
    /// Providers running on this host
    pub providers: ProviderDescriptions,
}

// Encode HostInventory as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_host_inventory<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &HostInventory,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(4)?;
    e.str("actors")?;
    encode_actor_descriptions(e, &val.actors)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("labels")?;
    encode_labels_map(e, &val.labels)?;
    e.str("providers")?;
    encode_provider_descriptions(e, &val.providers)?;
    Ok(())
}

// Decode HostInventory from cbor input stream
#[doc(hidden)]
pub fn decode_host_inventory(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<HostInventory, RpcError> {
    let __result = {
        let mut actors: Option<ActorDescriptions> = None;
        let mut host_id: Option<String> = None;
        let mut labels: Option<LabelsMap> = None;
        let mut providers: Option<ProviderDescriptions> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct HostInventory, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        actors = Some(decode_actor_descriptions(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ActorDescriptions': {}",
                                e
                            )
                        })?)
                    }
                    1 => host_id = Some(d.str()?.to_string()),
                    2 => {
                        labels = Some(decode_labels_map(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.lattice.control#LabelsMap': {}", e)
                        })?)
                    }
                    3 => {
                        providers = Some(decode_provider_descriptions(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ProviderDescriptions': {}",
                                e
                            )
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actors" => {
                        actors = Some(decode_actor_descriptions(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ActorDescriptions': {}",
                                e
                            )
                        })?)
                    }
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "labels" => {
                        labels = Some(decode_labels_map(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.lattice.control#LabelsMap': {}", e)
                        })?)
                    }
                    "providers" => {
                        providers = Some(decode_provider_descriptions(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ProviderDescriptions': {}",
                                e
                            )
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        }
        HostInventory {
            actors: if let Some(__x) = actors {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field HostInventory.actors (#0)".to_string(),
                ));
            },

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field HostInventory.host_id (#1)".to_string(),
                ));
            },

            labels: if let Some(__x) = labels {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field HostInventory.labels (#2)".to_string(),
                ));
            },

            providers: if let Some(__x) = providers {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field HostInventory.providers (#3)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type Hosts = Vec<Host>;

// Encode Hosts as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_hosts<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Hosts,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_host(e, item)?;
    }
    Ok(())
}

// Decode Hosts from cbor input stream
#[doc(hidden)]
pub fn decode_hosts(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Hosts, RpcError> {
    let __result =
        {
            if let Some(n) = d.array()? {
                let mut arr: Vec<Host> = Vec::with_capacity(n as usize);
                for _ in 0..(n as usize) {
                    arr.push(decode_host(d).map_err(|e| {
                        format!("decoding 'org.wasmcloud.lattice.control#Host': {}", e)
                    })?)
                }
                arr
            } else {
                // indefinite array
                let mut arr: Vec<Host> = Vec::new();
                loop {
                    match d.datatype() {
                        Err(_) => break,
                        Ok(wasmbus_rpc::cbor::Type::Break) => break,
                        Ok(_) => arr.push(decode_host(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.lattice.control#Host': {}", e)
                        })?),
                    }
                }
                arr
            }
        };
    Ok(__result)
}
pub type KeyValueMap = std::collections::HashMap<String, String>;

// Encode KeyValueMap as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_key_value_map<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &KeyValueMap,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(val.len() as u64)?;
    for (k, v) in val {
        e.str(k)?;
        e.str(v)?;
    }
    Ok(())
}

// Decode KeyValueMap from cbor input stream
#[doc(hidden)]
pub fn decode_key_value_map(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<KeyValueMap, RpcError> {
    let __result = {
        {
            let map_len = d.fixed_map()? as usize;
            let mut m: std::collections::HashMap<String, String> =
                std::collections::HashMap::with_capacity(map_len);
            for _ in 0..map_len {
                let k = d.str()?.to_string();
                let v = d.str()?.to_string();
                m.insert(k, v);
            }
            m
        }
    };
    Ok(__result)
}
pub type LabelsMap = std::collections::HashMap<String, String>;

// Encode LabelsMap as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_labels_map<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &LabelsMap,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(val.len() as u64)?;
    for (k, v) in val {
        e.str(k)?;
        e.str(v)?;
    }
    Ok(())
}

// Decode LabelsMap from cbor input stream
#[doc(hidden)]
pub fn decode_labels_map(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<LabelsMap, RpcError> {
    let __result = {
        {
            let map_len = d.fixed_map()? as usize;
            let mut m: std::collections::HashMap<String, String> =
                std::collections::HashMap::with_capacity(map_len);
            for _ in 0..map_len {
                let k = d.str()?.to_string();
                let v = d.str()?.to_string();
                m.insert(k, v);
            }
            m
        }
    };
    Ok(__result)
}
/// A list of link definitions
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct LinkDefinitionList {
    pub links: wasmbus_rpc::core::ActorLinks,
}

// Encode LinkDefinitionList as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_link_definition_list<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &LinkDefinitionList,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(1)?;
    e.str("links")?;
    wasmbus_rpc::core::encode_actor_links(e, &val.links)?;
    Ok(())
}

// Decode LinkDefinitionList from cbor input stream
#[doc(hidden)]
pub fn decode_link_definition_list(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<LinkDefinitionList, RpcError> {
    let __result = {
        let mut links: Option<wasmbus_rpc::core::ActorLinks> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct LinkDefinitionList, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        links = Some(wasmbus_rpc::core::decode_actor_links(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.core#ActorLinks': {}", e)
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "links" => {
                        links = Some(wasmbus_rpc::core::decode_actor_links(d).map_err(|e| {
                            format!("decoding 'org.wasmcloud.core#ActorLinks': {}", e)
                        })?)
                    }
                    _ => d.skip()?,
                }
            }
        }
        LinkDefinitionList {
            links: if let Some(__x) = links {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field LinkDefinitionList.links (#0)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// One of a potential list of responses to a provider auction
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProviderAuctionAck {
    /// The host ID of the "bidder" for this auction
    #[serde(default)]
    pub host_id: String,
    /// The link name provided for the auction
    #[serde(default)]
    pub link_name: String,
    /// The original provider ref provided for the auction
    #[serde(default)]
    pub provider_ref: String,
}

// Encode ProviderAuctionAck as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_provider_auction_ack<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ProviderAuctionAck,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("linkName")?;
    e.str(&val.link_name)?;
    e.str("providerRef")?;
    e.str(&val.provider_ref)?;
    Ok(())
}

// Decode ProviderAuctionAck from cbor input stream
#[doc(hidden)]
pub fn decode_provider_auction_ack(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ProviderAuctionAck, RpcError> {
    let __result = {
        let mut host_id: Option<String> = None;
        let mut link_name: Option<String> = None;
        let mut provider_ref: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ProviderAuctionAck, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => host_id = Some(d.str()?.to_string()),
                    1 => link_name = Some(d.str()?.to_string()),
                    2 => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "linkName" => link_name = Some(d.str()?.to_string()),
                    "providerRef" => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        ProviderAuctionAck {
            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderAuctionAck.host_id (#0)".to_string(),
                ));
            },

            link_name: if let Some(__x) = link_name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderAuctionAck.link_name (#1)".to_string(),
                ));
            },

            provider_ref: if let Some(__x) = provider_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderAuctionAck.provider_ref (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type ProviderAuctionAcks = Vec<ProviderAuctionAck>;

// Encode ProviderAuctionAcks as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_provider_auction_acks<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ProviderAuctionAcks,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_provider_auction_ack(e, item)?;
    }
    Ok(())
}

// Decode ProviderAuctionAcks from cbor input stream
#[doc(hidden)]
pub fn decode_provider_auction_acks(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ProviderAuctionAcks, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<ProviderAuctionAck> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_provider_auction_ack(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.lattice.control#ProviderAuctionAck': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<ProviderAuctionAck> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_provider_auction_ack(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.lattice.control#ProviderAuctionAck': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// A request to locate a suitable host for a capability provider. The
/// provider's unique identity (reference + link name) is used to rule
/// out sites on which the provider is already running.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProviderAuctionRequest {
    /// The set of constraints to which a suitable target host must conform
    pub constraints: ConstraintMap,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
    /// The link name of the provider
    #[serde(default)]
    pub link_name: String,
    /// The reference for the provider. Can be any one of the accepted
    /// forms of uniquely identifying a provider
    #[serde(default)]
    pub provider_ref: String,
}

// Encode ProviderAuctionRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_provider_auction_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ProviderAuctionRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(4)?;
    e.str("constraints")?;
    encode_constraint_map(e, &val.constraints)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    e.str("linkName")?;
    e.str(&val.link_name)?;
    e.str("providerRef")?;
    e.str(&val.provider_ref)?;
    Ok(())
}

// Decode ProviderAuctionRequest from cbor input stream
#[doc(hidden)]
pub fn decode_provider_auction_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ProviderAuctionRequest, RpcError> {
    let __result = {
        let mut constraints: Option<ConstraintMap> = None;
        let mut lattice_id: Option<String> = None;
        let mut link_name: Option<String> = None;
        let mut provider_ref: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ProviderAuctionRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        constraints = Some(decode_constraint_map(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ConstraintMap': {}",
                                e
                            )
                        })?)
                    }
                    1 => lattice_id = Some(d.str()?.to_string()),
                    2 => link_name = Some(d.str()?.to_string()),
                    3 => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "constraints" => {
                        constraints = Some(decode_constraint_map(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.lattice.control#ConstraintMap': {}",
                                e
                            )
                        })?)
                    }
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "linkName" => link_name = Some(d.str()?.to_string()),
                    "providerRef" => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        ProviderAuctionRequest {
            constraints: if let Some(__x) = constraints {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderAuctionRequest.constraints (#0)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderAuctionRequest.lattice_id (#1)".to_string(),
                ));
            },

            link_name: if let Some(__x) = link_name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderAuctionRequest.link_name (#2)".to_string(),
                ));
            },

            provider_ref: if let Some(__x) = provider_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderAuctionRequest.provider_ref (#3)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A summary description of a capability provider within a host inventory
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProviderDescription {
    /// Provider's unique 56-character ID
    #[serde(default)]
    pub id: String,
    /// Image reference for this provider, if applicable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_ref: Option<String>,
    /// Provider's link name
    #[serde(default)]
    pub link_name: String,
    /// Name of the provider, if one exists
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The revision of the provider
    #[serde(default)]
    pub revision: i32,
}

// Encode ProviderDescription as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_provider_description<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ProviderDescription,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(5)?;
    e.str("id")?;
    e.str(&val.id)?;
    if let Some(val) = val.image_ref.as_ref() {
        e.str("imageRef")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("linkName")?;
    e.str(&val.link_name)?;
    if let Some(val) = val.name.as_ref() {
        e.str("name")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("revision")?;
    e.i32(val.revision)?;
    Ok(())
}

// Decode ProviderDescription from cbor input stream
#[doc(hidden)]
pub fn decode_provider_description(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ProviderDescription, RpcError> {
    let __result = {
        let mut id: Option<String> = None;
        let mut image_ref: Option<Option<String>> = Some(None);
        let mut link_name: Option<String> = None;
        let mut name: Option<Option<String>> = Some(None);
        let mut revision: Option<i32> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ProviderDescription, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => id = Some(d.str()?.to_string()),
                    1 => {
                        image_ref = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => link_name = Some(d.str()?.to_string()),
                    3 => {
                        name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => revision = Some(d.i32()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "id" => id = Some(d.str()?.to_string()),
                    "imageRef" => {
                        image_ref = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "linkName" => link_name = Some(d.str()?.to_string()),
                    "name" => {
                        name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "revision" => revision = Some(d.i32()?),
                    _ => d.skip()?,
                }
            }
        }
        ProviderDescription {
            id: if let Some(__x) = id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderDescription.id (#0)".to_string(),
                ));
            },
            image_ref: image_ref.unwrap(),

            link_name: if let Some(__x) = link_name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderDescription.link_name (#2)".to_string(),
                ));
            },
            name: name.unwrap(),

            revision: if let Some(__x) = revision {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ProviderDescription.revision (#4)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type ProviderDescriptions = Vec<ProviderDescription>;

// Encode ProviderDescriptions as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_provider_descriptions<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ProviderDescriptions,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_provider_description(e, item)?;
    }
    Ok(())
}

// Decode ProviderDescriptions from cbor input stream
#[doc(hidden)]
pub fn decode_provider_descriptions(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ProviderDescriptions, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<ProviderDescription> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_provider_description(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.lattice.control#ProviderDescription': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<ProviderDescription> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_provider_description(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.lattice.control#ProviderDescription': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct RegistryCredential {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// If supplied, token authentication will be used for the registry
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// If supplied, username and password will be used for HTTP Basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

// Encode RegistryCredential as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_registry_credential<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &RegistryCredential,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    if let Some(val) = val.password.as_ref() {
        e.str("password")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.token.as_ref() {
        e.str("token")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.username.as_ref() {
        e.str("username")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode RegistryCredential from cbor input stream
#[doc(hidden)]
pub fn decode_registry_credential(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<RegistryCredential, RpcError> {
    let __result = {
        let mut password: Option<Option<String>> = Some(None);
        let mut token: Option<Option<String>> = Some(None);
        let mut username: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct RegistryCredential, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        password = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => {
                        token = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        username = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "password" => {
                        password = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "token" => {
                        token = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "username" => {
                        username = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        RegistryCredential {
            password: password.unwrap(),
            token: token.unwrap(),
            username: username.unwrap(),
        }
    };
    Ok(__result)
}
/// A set of credentials to be used for fetching from specific registries
pub type RegistryCredentialMap = std::collections::HashMap<String, RegistryCredential>;

// Encode RegistryCredentialMap as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_registry_credential_map<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &RegistryCredentialMap,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(val.len() as u64)?;
    for (k, v) in val {
        e.str(k)?;
        encode_registry_credential(e, v)?;
    }
    Ok(())
}

// Decode RegistryCredentialMap from cbor input stream
#[doc(hidden)]
pub fn decode_registry_credential_map(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<RegistryCredentialMap, RpcError> {
    let __result = {
        {
            let map_len = d.fixed_map()? as usize;
            let mut m: std::collections::HashMap<String, RegistryCredential> =
                std::collections::HashMap::with_capacity(map_len);
            for _ in 0..map_len {
                let k = d.str()?.to_string();
                let v = decode_registry_credential(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.lattice.control#RegistryCredential': {}",
                        e
                    )
                })?;
                m.insert(k, v);
            }
            m
        }
    };
    Ok(__result)
}
/// A request to remove a link definition and detach the relevant actor
/// from the given provider
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct RemoveLinkDefinitionRequest {
    /// The actor's public key. This cannot be an image reference
    #[serde(default)]
    pub actor_id: String,
    /// The provider contract
    #[serde(default)]
    pub contract_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
    /// The provider's link name
    #[serde(default)]
    pub link_name: String,
}

// Encode RemoveLinkDefinitionRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_remove_link_definition_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &RemoveLinkDefinitionRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(4)?;
    e.str("actorId")?;
    e.str(&val.actor_id)?;
    e.str("contractId")?;
    e.str(&val.contract_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    e.str("linkName")?;
    e.str(&val.link_name)?;
    Ok(())
}

// Decode RemoveLinkDefinitionRequest from cbor input stream
#[doc(hidden)]
pub fn decode_remove_link_definition_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<RemoveLinkDefinitionRequest, RpcError> {
    let __result = {
        let mut actor_id: Option<String> = None;
        let mut contract_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;
        let mut link_name: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct RemoveLinkDefinitionRequest, expected array or map"
                        .to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => actor_id = Some(d.str()?.to_string()),
                    1 => contract_id = Some(d.str()?.to_string()),
                    2 => lattice_id = Some(d.str()?.to_string()),
                    3 => link_name = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actorId" => actor_id = Some(d.str()?.to_string()),
                    "contractId" => contract_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "linkName" => link_name = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        RemoveLinkDefinitionRequest {
            actor_id: if let Some(__x) = actor_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field RemoveLinkDefinitionRequest.actor_id (#0)".to_string(),
                ));
            },

            contract_id: if let Some(__x) = contract_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field RemoveLinkDefinitionRequest.contract_id (#1)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field RemoveLinkDefinitionRequest.lattice_id (#2)".to_string(),
                ));
            },

            link_name: if let Some(__x) = link_name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field RemoveLinkDefinitionRequest.link_name (#3)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ScaleActorCommand {
    /// Public Key ID of the actor to scale
    #[serde(default)]
    pub actor_id: String,
    /// Reference for the actor. Can be any of the acceptable forms of unique identification
    #[serde(default)]
    pub actor_ref: String,
    /// Optional set of annotations used to describe the nature of this actor scale command. For
    /// example, autonomous agents may wish to "tag" scale requests as part of a given deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<AnnotationMap>,
    /// The target number of actors
    #[serde(default)]
    pub count: u16,
    /// Host ID on which to scale this actor
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
}

// Encode ScaleActorCommand as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_scale_actor_command<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ScaleActorCommand,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(6)?;
    e.str("actorId")?;
    e.str(&val.actor_id)?;
    e.str("actorRef")?;
    e.str(&val.actor_ref)?;
    if let Some(val) = val.annotations.as_ref() {
        e.str("annotations")?;
        encode_annotation_map(e, val)?;
    } else {
        e.null()?;
    }
    e.str("count")?;
    e.u16(val.count)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    Ok(())
}

// Decode ScaleActorCommand from cbor input stream
#[doc(hidden)]
pub fn decode_scale_actor_command(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ScaleActorCommand, RpcError> {
    let __result = {
        let mut actor_id: Option<String> = None;
        let mut actor_ref: Option<String> = None;
        let mut annotations: Option<Option<AnnotationMap>> = Some(None);
        let mut count: Option<u16> = None;
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ScaleActorCommand, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => actor_id = Some(d.str()?.to_string()),
                    1 => actor_ref = Some(d.str()?.to_string()),
                    2 => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    3 => count = Some(d.u16()?),
                    4 => host_id = Some(d.str()?.to_string()),
                    5 => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actorId" => actor_id = Some(d.str()?.to_string()),
                    "actorRef" => actor_ref = Some(d.str()?.to_string()),
                    "annotations" => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "count" => count = Some(d.u16()?),
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        ScaleActorCommand {
            actor_id: if let Some(__x) = actor_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ScaleActorCommand.actor_id (#0)".to_string(),
                ));
            },

            actor_ref: if let Some(__x) = actor_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ScaleActorCommand.actor_ref (#1)".to_string(),
                ));
            },
            annotations: annotations.unwrap(),

            count: if let Some(__x) = count {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ScaleActorCommand.count (#3)".to_string(),
                ));
            },

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ScaleActorCommand.host_id (#4)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ScaleActorCommand.lattice_id (#5)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// Represents a request to set/store the credentials that correspond to a given lattice ID.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SetLatticeCredentialsRequest {
    /// The ID of the lattice for which these credentials will be used
    #[serde(default)]
    pub lattice_id: String,
    /// If natsUrl is supplied, then the capability provider will use this URL (and port) for
    /// establishing a connection for the given lattice.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nats_url: Option<String>,
    /// If supplied, contains the user JWT to be used for authenticating against NATS to allow
    /// access to the indicated lattice. If not supplied, the capability provider will assume/set
    /// anonymous access for this lattice.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_jwt: Option<String>,
    /// If userJwt is supplied, user seed must also be supplied and is the seed key used for user
    /// authentication against NATS for this lattice.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_seed: Option<String>,
}

// Encode SetLatticeCredentialsRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_set_lattice_credentials_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SetLatticeCredentialsRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(4)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    if let Some(val) = val.nats_url.as_ref() {
        e.str("natsUrl")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.user_jwt.as_ref() {
        e.str("userJwt")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.user_seed.as_ref() {
        e.str("userSeed")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode SetLatticeCredentialsRequest from cbor input stream
#[doc(hidden)]
pub fn decode_set_lattice_credentials_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SetLatticeCredentialsRequest, RpcError> {
    let __result = {
        let mut lattice_id: Option<String> = None;
        let mut nats_url: Option<Option<String>> = Some(None);
        let mut user_jwt: Option<Option<String>> = Some(None);
        let mut user_seed: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SetLatticeCredentialsRequest, expected array or map"
                        .to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => lattice_id = Some(d.str()?.to_string()),
                    1 => {
                        nats_url = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        user_jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    3 => {
                        user_seed = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "natsUrl" => {
                        nats_url = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "userJwt" => {
                        user_jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "userSeed" => {
                        user_seed = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        SetLatticeCredentialsRequest {
            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SetLatticeCredentialsRequest.lattice_id (#0)".to_string(),
                ));
            },
            nats_url: nats_url.unwrap(),
            user_jwt: user_jwt.unwrap(),
            user_seed: user_seed.unwrap(),
        }
    };
    Ok(__result)
}
/// A command sent to a specific host instructing it to start the actor
/// indicated by the reference.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct StartActorCommand {
    /// Reference for the actor. Can be any of the acceptable forms of unique identification
    #[serde(default)]
    pub actor_ref: String,
    /// Optional set of annotations used to describe the nature of this actor start command. For
    /// example, autonomous agents may wish to "tag" start requests as part of a given deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<AnnotationMap>,
    /// The number of actors to start
    /// A zero value will be interpreted as 1.
    #[serde(default)]
    pub count: u16,
    /// Host ID on which this actor should start
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
}

// Encode StartActorCommand as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_start_actor_command<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &StartActorCommand,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(5)?;
    e.str("actorRef")?;
    e.str(&val.actor_ref)?;
    if let Some(val) = val.annotations.as_ref() {
        e.str("annotations")?;
        encode_annotation_map(e, val)?;
    } else {
        e.null()?;
    }
    e.str("count")?;
    e.u16(val.count)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    Ok(())
}

// Decode StartActorCommand from cbor input stream
#[doc(hidden)]
pub fn decode_start_actor_command(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<StartActorCommand, RpcError> {
    let __result = {
        let mut actor_ref: Option<String> = None;
        let mut annotations: Option<Option<AnnotationMap>> = Some(None);
        let mut count: Option<u16> = None;
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct StartActorCommand, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => actor_ref = Some(d.str()?.to_string()),
                    1 => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    2 => count = Some(d.u16()?),
                    3 => host_id = Some(d.str()?.to_string()),
                    4 => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actorRef" => actor_ref = Some(d.str()?.to_string()),
                    "annotations" => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "count" => count = Some(d.u16()?),
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        StartActorCommand {
            actor_ref: if let Some(__x) = actor_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartActorCommand.actor_ref (#0)".to_string(),
                ));
            },
            annotations: annotations.unwrap(),

            count: if let Some(__x) = count {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartActorCommand.count (#2)".to_string(),
                ));
            },

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartActorCommand.host_id (#3)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartActorCommand.lattice_id (#4)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A command sent to a host requesting a capability provider be started with the
/// given link name and optional configuration.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct StartProviderCommand {
    /// Optional set of annotations used to describe the nature of this provider start command. For
    /// example, autonomous agents may wish to "tag" start requests as part of a given deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<AnnotationMap>,
    /// Optional provider configuration in the form of an opaque string. Many
    /// providers prefer base64-encoded JSON here, though that data should never
    /// exceed 500KB
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<ConfigurationString>,
    /// The host ID on which to start the provider
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
    /// The link name of the provider to be started
    #[serde(default)]
    pub link_name: String,
    /// The image reference of the provider to be started
    #[serde(default)]
    pub provider_ref: String,
}

// Encode StartProviderCommand as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_start_provider_command<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &StartProviderCommand,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(6)?;
    if let Some(val) = val.annotations.as_ref() {
        e.str("annotations")?;
        encode_annotation_map(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.configuration.as_ref() {
        e.str("configuration")?;
        encode_configuration_string(e, val)?;
    } else {
        e.null()?;
    }
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    e.str("linkName")?;
    e.str(&val.link_name)?;
    e.str("providerRef")?;
    e.str(&val.provider_ref)?;
    Ok(())
}

// Decode StartProviderCommand from cbor input stream
#[doc(hidden)]
pub fn decode_start_provider_command(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<StartProviderCommand, RpcError> {
    let __result = {
        let mut annotations: Option<Option<AnnotationMap>> = Some(None);
        let mut configuration: Option<Option<ConfigurationString>> = Some(None);
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;
        let mut link_name: Option<String> = None;
        let mut provider_ref: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct StartProviderCommand, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    1 => {
                        configuration = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_configuration_string(d).map_err(|e| format!("decoding 'org.wasmcloud.lattice.control#ConfigurationString': {}", e))? ))
                        }
                    }
                    2 => host_id = Some(d.str()?.to_string()),
                    3 => lattice_id = Some(d.str()?.to_string()),
                    4 => link_name = Some(d.str()?.to_string()),
                    5 => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "annotations" => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "configuration" => {
                        configuration = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_configuration_string(d).map_err(|e| format!("decoding 'org.wasmcloud.lattice.control#ConfigurationString': {}", e))? ))
                        }
                    }
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "linkName" => link_name = Some(d.str()?.to_string()),
                    "providerRef" => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        StartProviderCommand {
            annotations: annotations.unwrap(),
            configuration: configuration.unwrap(),

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartProviderCommand.host_id (#2)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartProviderCommand.lattice_id (#3)".to_string(),
                ));
            },

            link_name: if let Some(__x) = link_name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartProviderCommand.link_name (#4)".to_string(),
                ));
            },

            provider_ref: if let Some(__x) = provider_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StartProviderCommand.provider_ref (#5)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A command sent to a host to request that instances of a given actor
/// be terminated on that host
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct StopActorCommand {
    /// Reference for this actor. Can be any of the means of uniquely identifying
    /// an actor
    #[serde(default)]
    pub actor_ref: String,
    /// Optional set of annotations used to describe the nature of this
    /// stop request. If supplied, the only instances of this actor with these
    /// annotations will be stopped
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<AnnotationMap>,
    /// The number of actors to stop
    /// A zero value means stop all actors
    #[serde(default)]
    pub count: u16,
    /// The ID of the target host
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
}

// Encode StopActorCommand as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_stop_actor_command<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &StopActorCommand,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(5)?;
    e.str("actorRef")?;
    e.str(&val.actor_ref)?;
    if let Some(val) = val.annotations.as_ref() {
        e.str("annotations")?;
        encode_annotation_map(e, val)?;
    } else {
        e.null()?;
    }
    e.str("count")?;
    e.u16(val.count)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    Ok(())
}

// Decode StopActorCommand from cbor input stream
#[doc(hidden)]
pub fn decode_stop_actor_command(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<StopActorCommand, RpcError> {
    let __result = {
        let mut actor_ref: Option<String> = None;
        let mut annotations: Option<Option<AnnotationMap>> = Some(None);
        let mut count: Option<u16> = None;
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct StopActorCommand, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => actor_ref = Some(d.str()?.to_string()),
                    1 => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    2 => count = Some(d.u16()?),
                    3 => host_id = Some(d.str()?.to_string()),
                    4 => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actorRef" => actor_ref = Some(d.str()?.to_string()),
                    "annotations" => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "count" => count = Some(d.u16()?),
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        StopActorCommand {
            actor_ref: if let Some(__x) = actor_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopActorCommand.actor_ref (#0)".to_string(),
                ));
            },
            annotations: annotations.unwrap(),

            count: if let Some(__x) = count {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopActorCommand.count (#2)".to_string(),
                ));
            },

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopActorCommand.host_id (#3)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopActorCommand.lattice_id (#4)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A command sent to request that the given host purge and stop
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct StopHostCommand {
    /// The ID of the target host
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
    /// An optional timeout, in seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<u64>,
}

// Encode StopHostCommand as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_stop_host_command<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &StopHostCommand,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    if let Some(val) = val.timeout.as_ref() {
        e.str("timeout")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode StopHostCommand from cbor input stream
#[doc(hidden)]
pub fn decode_stop_host_command(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<StopHostCommand, RpcError> {
    let __result = {
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;
        let mut timeout: Option<Option<u64>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct StopHostCommand, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => host_id = Some(d.str()?.to_string()),
                    1 => lattice_id = Some(d.str()?.to_string()),
                    2 => {
                        timeout = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "timeout" => {
                        timeout = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        StopHostCommand {
            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopHostCommand.host_id (#0)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopHostCommand.lattice_id (#1)".to_string(),
                ));
            },
            timeout: timeout.unwrap(),
        }
    };
    Ok(__result)
}
/// A request to stop the given provider on the indicated host
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct StopProviderCommand {
    /// Optional set of annotations used to describe the nature of this
    /// stop request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<AnnotationMap>,
    /// Contract ID of the capability provider
    #[serde(default)]
    pub contract_id: String,
    /// Host ID on which to stop the provider
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
    /// Link name for this provider
    #[serde(default)]
    pub link_name: String,
    /// Reference for the capability provider. Can be any of the forms of
    /// uniquely identifying a provider
    #[serde(default)]
    pub provider_ref: String,
}

// Encode StopProviderCommand as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_stop_provider_command<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &StopProviderCommand,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(6)?;
    if let Some(val) = val.annotations.as_ref() {
        e.str("annotations")?;
        encode_annotation_map(e, val)?;
    } else {
        e.null()?;
    }
    e.str("contractId")?;
    e.str(&val.contract_id)?;
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    e.str("linkName")?;
    e.str(&val.link_name)?;
    e.str("providerRef")?;
    e.str(&val.provider_ref)?;
    Ok(())
}

// Decode StopProviderCommand from cbor input stream
#[doc(hidden)]
pub fn decode_stop_provider_command(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<StopProviderCommand, RpcError> {
    let __result = {
        let mut annotations: Option<Option<AnnotationMap>> = Some(None);
        let mut contract_id: Option<String> = None;
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;
        let mut link_name: Option<String> = None;
        let mut provider_ref: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct StopProviderCommand, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    1 => contract_id = Some(d.str()?.to_string()),
                    2 => host_id = Some(d.str()?.to_string()),
                    3 => lattice_id = Some(d.str()?.to_string()),
                    4 => link_name = Some(d.str()?.to_string()),
                    5 => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "annotations" => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "contractId" => contract_id = Some(d.str()?.to_string()),
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "linkName" => link_name = Some(d.str()?.to_string()),
                    "providerRef" => provider_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        StopProviderCommand {
            annotations: annotations.unwrap(),

            contract_id: if let Some(__x) = contract_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopProviderCommand.contract_id (#1)".to_string(),
                ));
            },

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopProviderCommand.host_id (#2)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopProviderCommand.lattice_id (#3)".to_string(),
                ));
            },

            link_name: if let Some(__x) = link_name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopProviderCommand.link_name (#4)".to_string(),
                ));
            },

            provider_ref: if let Some(__x) = provider_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field StopProviderCommand.provider_ref (#5)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// A command instructing a specific host to perform a live update
/// on the indicated actor by supplying a new image reference. Note that
/// live updates are only possible through image references
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct UpdateActorCommand {
    /// The actor's 56-character unique ID
    #[serde(default)]
    pub actor_id: String,
    /// Optional set of annotations used to describe the nature of this
    /// update request. Only actor instances that have matching annotations
    /// will be upgraded, allowing for instance isolation by
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<AnnotationMap>,
    /// The host ID of the host to perform the live update
    #[serde(default)]
    pub host_id: String,
    /// The ID of the lattice on which this request will be performed
    #[serde(default)]
    pub lattice_id: String,
    /// The new image reference of the upgraded version of this actor
    #[serde(default)]
    pub new_actor_ref: String,
}

// Encode UpdateActorCommand as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_update_actor_command<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &UpdateActorCommand,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(5)?;
    e.str("actorId")?;
    e.str(&val.actor_id)?;
    if let Some(val) = val.annotations.as_ref() {
        e.str("annotations")?;
        encode_annotation_map(e, val)?;
    } else {
        e.null()?;
    }
    e.str("hostId")?;
    e.str(&val.host_id)?;
    e.str("latticeId")?;
    e.str(&val.lattice_id)?;
    e.str("newActorRef")?;
    e.str(&val.new_actor_ref)?;
    Ok(())
}

// Decode UpdateActorCommand from cbor input stream
#[doc(hidden)]
pub fn decode_update_actor_command(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<UpdateActorCommand, RpcError> {
    let __result = {
        let mut actor_id: Option<String> = None;
        let mut annotations: Option<Option<AnnotationMap>> = Some(None);
        let mut host_id: Option<String> = None;
        let mut lattice_id: Option<String> = None;
        let mut new_actor_ref: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct UpdateActorCommand, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => actor_id = Some(d.str()?.to_string()),
                    1 => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    2 => host_id = Some(d.str()?.to_string()),
                    3 => lattice_id = Some(d.str()?.to_string()),
                    4 => new_actor_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "actorId" => actor_id = Some(d.str()?.to_string()),
                    "annotations" => {
                        annotations = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_annotation_map(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.lattice.control#AnnotationMap': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "hostId" => host_id = Some(d.str()?.to_string()),
                    "latticeId" => lattice_id = Some(d.str()?.to_string()),
                    "newActorRef" => new_actor_ref = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        UpdateActorCommand {
            actor_id: if let Some(__x) = actor_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field UpdateActorCommand.actor_id (#0)".to_string(),
                ));
            },
            annotations: annotations.unwrap(),

            host_id: if let Some(__x) = host_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field UpdateActorCommand.host_id (#2)".to_string(),
                ));
            },

            lattice_id: if let Some(__x) = lattice_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field UpdateActorCommand.lattice_id (#3)".to_string(),
                ));
            },

            new_actor_ref: if let Some(__x) = new_actor_ref {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field UpdateActorCommand.new_actor_ref (#4)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// Lattice Controller - Describes the interface used for actors
/// to communicate with a lattice controller, enabling developers
/// to deploy actors that can manipulate the lattice in which they're
/// running.
/// wasmbus.contractId: wasmcloud:latticecontrol
/// wasmbus.providerReceive
#[async_trait]
pub trait LatticeController {
    /// returns the capability contract id for this interface
    fn contract_id() -> &'static str {
        "wasmcloud:latticecontrol"
    }
    /// Seek out a list of suitable hosts for a capability provider given
    /// a set of host label constraints. Hosts on which this provider is already
    /// running will not be among the successful "bidders" in this auction.
    async fn auction_provider(
        &self,
        ctx: &Context,
        arg: &ProviderAuctionRequest,
    ) -> RpcResult<ProviderAuctionAcks>;
    /// Seek out a list of suitable hosts for an actor given a set of host
    /// label constraints.
    async fn auction_actor(
        &self,
        ctx: &Context,
        arg: &ActorAuctionRequest,
    ) -> RpcResult<ActorAuctionAcks>;
    /// Queries the list of hosts currently visible to the lattice. This is
    /// a "gather" operation and so can be influenced by short timeouts,
    /// network partition events, etc.
    async fn get_hosts(&self, ctx: &Context, arg: &GetHostsRequest) -> RpcResult<Hosts>;
    /// Queries for the contents of a host given the supplied 56-character unique ID
    async fn get_host_inventory(
        &self,
        ctx: &Context,
        arg: &GetHostInventoryRequest,
    ) -> RpcResult<HostInventory>;
    /// Queries the lattice for the list of known/cached claims by taking the response
    /// from the first host that answers the query.
    async fn get_claims(
        &self,
        ctx: &Context,
        arg: &GetClaimsRequest,
    ) -> RpcResult<GetClaimsResponse>;
    /// Instructs a given host to scale the indicated actor
    async fn scale_actor(
        &self,
        ctx: &Context,
        arg: &ScaleActorCommand,
    ) -> RpcResult<CtlOperationAck>;
    /// Instructs a given host to start the indicated actor
    async fn start_actor(
        &self,
        ctx: &Context,
        arg: &StartActorCommand,
    ) -> RpcResult<CtlOperationAck>;
    /// Publish a link definition into the lattice, allowing it to be cached and
    /// delivered to the appropriate capability provider instances
    async fn advertise_link(
        &self,
        ctx: &Context,
        arg: &AdvertiseLinkRequest,
    ) -> RpcResult<CtlOperationAck>;
    /// Requests the removal of a link definition. The definition will be removed
    /// from the cache and the relevant capability providers will be given a chance
    /// to de-provision any used resources
    async fn remove_link(
        &self,
        ctx: &Context,
        arg: &RemoveLinkDefinitionRequest,
    ) -> RpcResult<CtlOperationAck>;
    /// Queries all current link definitions in the lattice. The first host
    /// that receives this response will reply with the contents of the distributed
    /// cache
    async fn get_links(&self, ctx: &Context) -> RpcResult<LinkDefinitionList>;
    /// Requests that a specific host perform a live update on the indicated
    /// actor
    async fn update_actor(
        &self,
        ctx: &Context,
        arg: &UpdateActorCommand,
    ) -> RpcResult<CtlOperationAck>;
    /// Requests that the given host start the indicated capability provider
    async fn start_provider(
        &self,
        ctx: &Context,
        arg: &StartProviderCommand,
    ) -> RpcResult<CtlOperationAck>;
    /// Requests that the given capability provider be stopped on the indicated host
    async fn stop_provider(
        &self,
        ctx: &Context,
        arg: &StopProviderCommand,
    ) -> RpcResult<CtlOperationAck>;
    /// Requests that an actor be stopped on the given host
    async fn stop_actor(&self, ctx: &Context, arg: &StopActorCommand)
        -> RpcResult<CtlOperationAck>;
    async fn stop_host(&self, ctx: &Context, arg: &StopHostCommand) -> RpcResult<CtlOperationAck>;
    /// Instructs the provider to store the NATS credentials/URL for a given lattice. This is
    /// designed to allow a single capability provider (or multiple instances of the same) to manage
    /// multiple lattices, reducing overhead and making it easier to support secure multi-tenancy of
    /// lattices.
    async fn set_lattice_credentials(
        &self,
        ctx: &Context,
        arg: &SetLatticeCredentialsRequest,
    ) -> RpcResult<CtlOperationAck>;
    /// Instructs all listening hosts to use the enclosed credential map for
    /// authentication to secure artifact (OCI/bindle) registries. Any host that
    /// receives this message will _delete_ its previous credential map and replace
    /// it with the enclosed. The credential map for a lattice can be purged by sending
    /// this message with an empty map
    async fn set_registry_credentials(
        &self,
        ctx: &Context,
        arg: &RegistryCredentialMap,
    ) -> RpcResult<()>;
}

/// LatticeControllerReceiver receives messages defined in the LatticeController service trait
/// Lattice Controller - Describes the interface used for actors
/// to communicate with a lattice controller, enabling developers
/// to deploy actors that can manipulate the lattice in which they're
/// running.
#[doc(hidden)]
#[async_trait]
pub trait LatticeControllerReceiver: MessageDispatch + LatticeController {
    async fn dispatch<'disp__, 'ctx__, 'msg__>(
        &'disp__ self,
        ctx: &'ctx__ Context,
        message: &Message<'msg__>,
    ) -> Result<Message<'msg__>, RpcError> {
        match message.method {
            "AuctionProvider" => {
                let value: ProviderAuctionRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'ProviderAuctionRequest': {}", e)))?;

                let resp = LatticeController::auction_provider(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.AuctionProvider",
                    arg: Cow::Owned(buf),
                })
            }
            "AuctionActor" => {
                let value: ActorAuctionRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'ActorAuctionRequest': {}", e)))?;

                let resp = LatticeController::auction_actor(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.AuctionActor",
                    arg: Cow::Owned(buf),
                })
            }
            "GetHosts" => {
                let value: GetHostsRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'GetHostsRequest': {}", e)))?;

                let resp = LatticeController::get_hosts(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.GetHosts",
                    arg: Cow::Owned(buf),
                })
            }
            "GetHostInventory" => {
                let value: GetHostInventoryRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'GetHostInventoryRequest': {}", e)))?;

                let resp = LatticeController::get_host_inventory(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.GetHostInventory",
                    arg: Cow::Owned(buf),
                })
            }
            "GetClaims" => {
                let value: GetClaimsRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'GetClaimsRequest': {}", e)))?;

                let resp = LatticeController::get_claims(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.GetClaims",
                    arg: Cow::Owned(buf),
                })
            }
            "ScaleActor" => {
                let value: ScaleActorCommand = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'ScaleActorCommand': {}", e)))?;

                let resp = LatticeController::scale_actor(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.ScaleActor",
                    arg: Cow::Owned(buf),
                })
            }
            "StartActor" => {
                let value: StartActorCommand = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'StartActorCommand': {}", e)))?;

                let resp = LatticeController::start_actor(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.StartActor",
                    arg: Cow::Owned(buf),
                })
            }
            "AdvertiseLink" => {
                let value: AdvertiseLinkRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'AdvertiseLinkRequest': {}", e)))?;

                let resp = LatticeController::advertise_link(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.AdvertiseLink",
                    arg: Cow::Owned(buf),
                })
            }
            "RemoveLink" => {
                let value: RemoveLinkDefinitionRequest =
                    wasmbus_rpc::common::deserialize(&message.arg).map_err(|e| {
                        RpcError::Deser(format!("'RemoveLinkDefinitionRequest': {}", e))
                    })?;

                let resp = LatticeController::remove_link(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.RemoveLink",
                    arg: Cow::Owned(buf),
                })
            }
            "GetLinks" => {
                let resp = LatticeController::get_links(self, ctx).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.GetLinks",
                    arg: Cow::Owned(buf),
                })
            }
            "UpdateActor" => {
                let value: UpdateActorCommand = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'UpdateActorCommand': {}", e)))?;

                let resp = LatticeController::update_actor(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.UpdateActor",
                    arg: Cow::Owned(buf),
                })
            }
            "StartProvider" => {
                let value: StartProviderCommand = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'StartProviderCommand': {}", e)))?;

                let resp = LatticeController::start_provider(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.StartProvider",
                    arg: Cow::Owned(buf),
                })
            }
            "StopProvider" => {
                let value: StopProviderCommand = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'StopProviderCommand': {}", e)))?;

                let resp = LatticeController::stop_provider(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.StopProvider",
                    arg: Cow::Owned(buf),
                })
            }
            "StopActor" => {
                let value: StopActorCommand = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'StopActorCommand': {}", e)))?;

                let resp = LatticeController::stop_actor(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.StopActor",
                    arg: Cow::Owned(buf),
                })
            }
            "StopHost" => {
                let value: StopHostCommand = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'StopHostCommand': {}", e)))?;

                let resp = LatticeController::stop_host(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.StopHost",
                    arg: Cow::Owned(buf),
                })
            }
            "SetLatticeCredentials" => {
                let value: SetLatticeCredentialsRequest =
                    wasmbus_rpc::common::deserialize(&message.arg).map_err(|e| {
                        RpcError::Deser(format!("'SetLatticeCredentialsRequest': {}", e))
                    })?;

                let resp = LatticeController::set_lattice_credentials(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(Message {
                    method: "LatticeController.SetLatticeCredentials",
                    arg: Cow::Owned(buf),
                })
            }
            "SetRegistryCredentials" => {
                let value: RegistryCredentialMap =
                    wasmbus_rpc::common::deserialize(&message.arg)
                        .map_err(|e| RpcError::Deser(format!("'RegistryCredentialMap': {}", e)))?;

                let _resp = LatticeController::set_registry_credentials(self, ctx, &value).await?;
                let buf = Vec::new();
                Ok(Message {
                    method: "LatticeController.SetRegistryCredentials",
                    arg: Cow::Owned(buf),
                })
            }
            _ => Err(RpcError::MethodNotHandled(format!(
                "LatticeController::{}",
                message.method
            ))),
        }
    }
}

/// LatticeControllerSender sends messages to a LatticeController service
/// Lattice Controller - Describes the interface used for actors
/// to communicate with a lattice controller, enabling developers
/// to deploy actors that can manipulate the lattice in which they're
/// running.
/// client for sending LatticeController messages
#[derive(Debug)]
pub struct LatticeControllerSender<T: Transport> {
    transport: T,
}

impl<T: Transport> LatticeControllerSender<T> {
    /// Constructs a LatticeControllerSender with the specified transport
    pub fn via(transport: T) -> Self {
        Self { transport }
    }

    pub fn set_timeout(&self, interval: std::time::Duration) {
        self.transport.set_timeout(interval);
    }
}

#[cfg(target_arch = "wasm32")]
impl LatticeControllerSender<wasmbus_rpc::actor::prelude::WasmHost> {
    /// Constructs a client for sending to a LatticeController provider
    /// implementing the 'wasmcloud:latticecontrol' capability contract, with the "default" link
    pub fn new() -> Self {
        let transport = wasmbus_rpc::actor::prelude::WasmHost::to_provider(
            "wasmcloud:latticecontrol",
            "default",
        )
        .unwrap();
        Self { transport }
    }

    /// Constructs a client for sending to a LatticeController provider
    /// implementing the 'wasmcloud:latticecontrol' capability contract, with the specified link name
    pub fn new_with_link(link_name: &str) -> wasmbus_rpc::error::RpcResult<Self> {
        let transport = wasmbus_rpc::actor::prelude::WasmHost::to_provider(
            "wasmcloud:latticecontrol",
            link_name,
        )?;
        Ok(Self { transport })
    }
}
#[async_trait]
impl<T: Transport + std::marker::Sync + std::marker::Send> LatticeController
    for LatticeControllerSender<T>
{
    #[allow(unused)]
    /// Seek out a list of suitable hosts for a capability provider given
    /// a set of host label constraints. Hosts on which this provider is already
    /// running will not be among the successful "bidders" in this auction.
    async fn auction_provider(
        &self,
        ctx: &Context,
        arg: &ProviderAuctionRequest,
    ) -> RpcResult<ProviderAuctionAcks> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.AuctionProvider",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: ProviderAuctionAcks = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': ProviderAuctionAcks", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Seek out a list of suitable hosts for an actor given a set of host
    /// label constraints.
    async fn auction_actor(
        &self,
        ctx: &Context,
        arg: &ActorAuctionRequest,
    ) -> RpcResult<ActorAuctionAcks> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.AuctionActor",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: ActorAuctionAcks = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': ActorAuctionAcks", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Queries the list of hosts currently visible to the lattice. This is
    /// a "gather" operation and so can be influenced by short timeouts,
    /// network partition events, etc.
    async fn get_hosts(&self, ctx: &Context, arg: &GetHostsRequest) -> RpcResult<Hosts> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.GetHosts",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: Hosts = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': Hosts", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Queries for the contents of a host given the supplied 56-character unique ID
    async fn get_host_inventory(
        &self,
        ctx: &Context,
        arg: &GetHostInventoryRequest,
    ) -> RpcResult<HostInventory> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.GetHostInventory",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: HostInventory = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': HostInventory", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Queries the lattice for the list of known/cached claims by taking the response
    /// from the first host that answers the query.
    async fn get_claims(
        &self,
        ctx: &Context,
        arg: &GetClaimsRequest,
    ) -> RpcResult<GetClaimsResponse> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.GetClaims",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: GetClaimsResponse = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': GetClaimsResponse", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Instructs a given host to scale the indicated actor
    async fn scale_actor(
        &self,
        ctx: &Context,
        arg: &ScaleActorCommand,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.ScaleActor",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Instructs a given host to start the indicated actor
    async fn start_actor(
        &self,
        ctx: &Context,
        arg: &StartActorCommand,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.StartActor",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Publish a link definition into the lattice, allowing it to be cached and
    /// delivered to the appropriate capability provider instances
    async fn advertise_link(
        &self,
        ctx: &Context,
        arg: &AdvertiseLinkRequest,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.AdvertiseLink",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Requests the removal of a link definition. The definition will be removed
    /// from the cache and the relevant capability providers will be given a chance
    /// to de-provision any used resources
    async fn remove_link(
        &self,
        ctx: &Context,
        arg: &RemoveLinkDefinitionRequest,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.RemoveLink",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Queries all current link definitions in the lattice. The first host
    /// that receives this response will reply with the contents of the distributed
    /// cache
    async fn get_links(&self, ctx: &Context) -> RpcResult<LinkDefinitionList> {
        let buf = *b"";
        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.GetLinks",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: LinkDefinitionList = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': LinkDefinitionList", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Requests that a specific host perform a live update on the indicated
    /// actor
    async fn update_actor(
        &self,
        ctx: &Context,
        arg: &UpdateActorCommand,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.UpdateActor",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Requests that the given host start the indicated capability provider
    async fn start_provider(
        &self,
        ctx: &Context,
        arg: &StartProviderCommand,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.StartProvider",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Requests that the given capability provider be stopped on the indicated host
    async fn stop_provider(
        &self,
        ctx: &Context,
        arg: &StopProviderCommand,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.StopProvider",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Requests that an actor be stopped on the given host
    async fn stop_actor(
        &self,
        ctx: &Context,
        arg: &StopActorCommand,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.StopActor",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    async fn stop_host(&self, ctx: &Context, arg: &StopHostCommand) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.StopHost",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Instructs the provider to store the NATS credentials/URL for a given lattice. This is
    /// designed to allow a single capability provider (or multiple instances of the same) to manage
    /// multiple lattices, reducing overhead and making it easier to support secure multi-tenancy of
    /// lattices.
    async fn set_lattice_credentials(
        &self,
        ctx: &Context,
        arg: &SetLatticeCredentialsRequest,
    ) -> RpcResult<CtlOperationAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.SetLatticeCredentials",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: CtlOperationAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': CtlOperationAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Instructs all listening hosts to use the enclosed credential map for
    /// authentication to secure artifact (OCI/bindle) registries. Any host that
    /// receives this message will _delete_ its previous credential map and replace
    /// it with the enclosed. The credential map for a lattice can be purged by sending
    /// this message with an empty map
    async fn set_registry_credentials(
        &self,
        ctx: &Context,
        arg: &RegistryCredentialMap,
    ) -> RpcResult<()> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "LatticeController.SetRegistryCredentials",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;
        Ok(())
    }
}
